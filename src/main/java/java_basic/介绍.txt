---------------------------------------------------------------------------------------------------------
public类:
一个java源文件中只有一个public类，类名必须与java文件名相同；源文件中可以有多个类，并且可以没有public类，此时类名与文件名不必一致，
无论是public类与否都可以有main方法，这个main方法就可以作为java程序的入口；有多个类的源文件编译后会生成多个.class文件对应多个类，
在命令行里可以分别运行这些.class文件(只要该类实现了main方法);
类名与文件名相同这点还是可以理解的，比如编译后的文件，解释器去找名称与编译前文件名相同的那个类，从它的main方法开始执行程序；
public类可以在别的包中被导入使用，而一般类只能在本包中使用；
public标记与"类名与文件名相同"这两点强制放在一起的因由，这里还是令人困惑。
---------------------------------------------------------------------------------------------------------
类间关系：
1.依赖关系dependence，记为uses-a，如果A类的方法使用了B类的对象，那么就说A依赖B，这种情况下B类的改变可能会导致A类中出现bug，应该减少依赖，即尽量让依赖度小；
2.聚合关系aggregation，记为has-a,如果A类对象包含B类对象，换句话说B类对象是A类对象的实例域
3.继承关系inheritance，记为is-a,如果A类继承了B类，则A类具有B类所有的内容

-----------------------------------------------------------------------------------------------------------------
对象变量保存的实际上是在另一个地方存储的对象的引用，new操作的返回值就是一个引用
-----------------------------------------------------------------------------------------------------------------
构造器:
1.构造器与类同名
2.每个类可以有一个以上构造器
3.构造器可以有0至多个参数
4.构造器没有返回值
5.构造器总是伴随着new操作被隐式调用
--------------------------------------------------------------------------------------------------------
获取或设置实例域的内容，一般提供下面三项内容：
1.一个私有的数据域
2.一个公有的域访问器方法
3.一个公有的域更改器方法
需要注意的是如果访问器方法返回一个可变对象的引用，那么就破坏了封装性，所以先要对目标对象进行clone然后返回副本的引用
--------------------------------------------------------------------------------------------------------
final实例域：
1.final用于基本类型域(primitive,如int)或不可变(immutable，如String)类型域时，其内容不会改变；
2.而对于可变对象，final限定的是该引用不会指向其他对象，而不是限定该引用指向的对象不可变，比如private final StringBuilder evalutions;之后在构造器中初始化，
evalutions = new StringBuilder();evalutions这不能指向其他对象了，但是其指向的对象如果是可变的那就可变(1中的String不可变与final的限定无关，int不可变
才是final限定导致的),evalutions.append("Good");
----------------------------------------------------------------------------------------------------------
静态域：
静态域在内存中只有一个存在，被所有对象共享(共同访问与操作),也可由类名或对象名直接访问。一般使用静态常量而不是静态变量，如public static final PI=3.14.
Java中常量一般用大写。
----------------------------------------------------------------------------------------------------------------
静态方法：
静态方法没有隐式参数this(非静态方法的第一个参数隐式地为this)，不能操作实例域，可以操作静态域。直接用类名或对象名调用。
main方法是一个静态方法，运行程序的步骤即是从名称为Test的class的文件中去找名称为Test的公共类，然后执行其main方法，不需要创立对象；任何类都可以有main
方法，例如StaticTest.java中包含一个public类A和非public类B，两个类都具有main方法，编译后一个类会生成一个.class文件，运行Java B,则B中
的main方法会执行
----------------------------------------------------------------------------------------------------------------------
方法参数：
Java的方法接收的是实参的拷贝，被称为按值调用call by value。所以，当参数是基本类型时，方法内的操作不会影响实参的值，当参数是可变对象类型时，因为拷贝的是个引用，所以方法内的操作是可以影响到
这个引用所指向的对象的，但引用本身的改变(比如指向了其他对象)并不影响实参变量那个引用，这很好理解，毕竟无论传入的是什么，方法使用的都是它的拷贝
----------------------------------------------------------------------------------------------------------------------
重载overloading：
同一个类中多个同名方法形成了重载。方法名和和参数(参数的数量或类型或顺序)构成方法签名，编译器以此来来匹配调用的那个方法，返回类型不是方法签名的一部分，不能
用来区分方法。构造器也是方法，也可以重载，new对象时根据参数的不同调用不同的构造函数
-----------------------------------------------------------------------------------------------------------------------
域的初始化：
在构造器中如果没有显示地给域赋值，那么域就会被赋为默认值，数值为0，布尔值为false，对象引用为null。可以在声明时给出实例域的初值，这样在执行构造器之前
实例域就有了我们设定的值。
在初始化域时一般用this来指示实例域，比如this.name=name;this的作用不止于此，还可以在构造器中调用另一个构造器：this(参数...)，括号里填写另一个构造器接收
的参数。
还可以初始化块中初始化实例域：
静态域在加载类的时候执行一次初始化，该值如果在声明的时候没有给出那么就使用默认值，或者是在静态初始化块中执行一次初始化(形如static{初始化内容})
实例域的初始化如下进行new对象时：
1.按照声明初始化，声明中没有初始化则按默认值初始化
2.执行代码块，代码块中可进行初始化
3.执行构造器，构造器中可进行初始化
-----------------------------------------------------------------------------------------------------------------------
import：
一个类可以导入本包下的所有类，可以导入其他包下的public类。在包中定位类是编译器的工作，编译成的字节码使用完整的报名引用其他类。
import a.b.c,其中c是类；也可以import a.b.*;即导入b下的所有类;类重名时需要拼上完整的包路径来使用，否则会编译报错。
静态导入：可以导入一个类的静态方法或静态域，如import static java.lang.System.*;那么就可以直接使用out.println();
需要注意的是import命令位于文件开头，但package命令之后
-----------------------------------------------------------------------------------------------------------------------
将类放入包中：
在源文件的开头使用package命令指明源文件的类中，如package com.mingzhu;那么就应该将源文件放在目录层级为com/mingzhu下，否则的话编译
可能没问题(如果不涉及导入其他类使用上的问题)，形成的.class文件就在当前编译所在的位置；执行的时候(具体地就是java com.mingzhu.Test)要把该字节码文件放到
com/mingzhu这个层级下，否则解释器在该目录下(package命令指明过)找不到Test字节码文件就会报错。我们会自然想到如果在字节码文件所在的位置执行运行指令是否可以，
如java Test,这样也是错误的，因为字节码文件中package指令限定了类所在包位置，而跟执行时(java命令)指定的位置不一致，那么就会报错。这也就从实质层面上控制了
类所在的包，起到了隔离、权限控制等作用。
-----------------------------------------------------------------------------------------------------------------------
super和this:
this是个引用，指向的就是本对象，而super只是一个表示超类的符号，编译器据此来调用超类的方法。比如子类和超类都有getPrice()这个方法，现有一个子类的
对象c,子类的getPrice()的第一个隐参数this指向的就是这个对象，此外，直接c.getPrice()，调用的也是子类定义的getPrice()函数(如果子类没有这个函数才会去父类中找)，
而如果想使用父类的getPrice()就应该使用super.getPrice()。
super关键字的另一个作用是调用超类的构造器(有时这是必要的，比如子类不能访问超类的私有域，只能通过超类的构造器来初始化它们)，在子类构造器的第一行使用super(参数...)来
调用超类的构造器，如果没有显式地调用，那么就会默认调用超类的无参构造器(如果有的话,没有则编译器报错)
-----------------------------------------------------------------------------------------------------------------------
多态polymorphism:
Java不支持多继承(即一个类同时继承2个及以上类),但继承关系可以传递下去(即一个类的子类也可以是另一个类的超类，这样传递下去)。继承链中靠后的类的对象变量可以赋给其任意上游的父类
类型的对象变量，比如A->B->C->D(靠前的为父类),d = new D();d可以赋给ABC中任一类型的对象变量，比如B b = c;这叫作多态；虽然b和c引用的都是上面创建的那个对象，但b只拥有B类
所定义的数据与方法，比如b.getPrice()(加入getPrice()函数在B和D中都定义了话)，这个getPrice()肯定是B中所定义的；简单来说，编译器把b看作是B类的对象；这叫作动态绑定dynamic
binding。
需要注意的细节是：
子类数组可以赋给超类数组，得到的超类数组变量和子类数组变量指向同一个数组，它们操作其中元素的时候要注意对对方的影响，比如D[] dArray = new D[10];B[] bArray = dArray;
现在进行这样的操作，bArray[0] = new B();那么现在dArray[0]引用的也是一个B类对象了，这就出了问题。







